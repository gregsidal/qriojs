<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Qrio Qr/Bar Code Generator and Reader</title>

  <!-- <link  href="lib/qrio.css" rel="stylesheet" type="text/css"> -->
  <style>
/* some default css for QrioJS @ githib/gregsidal */

/* widget framing */
.qrio-widget {
  position: fixed; left: 0em; top: 0em; right: 0em; bottom: 0em;
  background-color: rgba(255,255,255,1.0); padding: 0.5em;
  visibility: visible; opacity: 1.0; transition: opacity 0.8s ease-in;
}
.qrio-widget.qrio-closed {visibility: hidden; opacity: 0.0;}
.qrio-widget > .qrio-widget {position: absolute;}
.qrio-controls {position: absolute; top: 0.5em; left: 0.5em; right: 0.5em;}
.qrio-exitbtn {position: absolute; top: 0; right: 0;}

/* status and message displays */
.qrio-status {
  max-width: 100%; max-height: 50%; overflow: auto;
  padding: 0.6em 0.7em; padding-bottom: 1.1em;
  background-color: rgba(235,235,235,0.8);
  font-family: monospace; font-size: 95%;
}
.qrio-status:empty {display: none;}
.qrio-status > div > .qrio-extracted {display: block; margin-top: 0.5em; white-space: nowrap;}
.qrio-extracted > .qrio-check        {cursor: pointer; margin-right: 0.3em; width: auto; border: 0;}

.qrio-extracted > .qrio-msg          {padding: 0.15em 0.1em; cursor: pointer;}
.qrio-extracted > .qrio-msg.qrio-c0  {background-color: rgba(85,240,40,0.15);}
.qrio-extracted > .qrio-msg.qrio-c1  {background-color: rgba(240,140,20,0.15);}
.qrio-extracted > .qrio-msg.qrio-c2  {background-color: rgba(240,240,40,0.2);}
.qrio-extracted > .qrio-msg.qrio-c3  {background-color: rgba(40,40,240,0.1);}
.qrio-extracted > .qrio-msg.qrio-c4  {background-color: rgba(220,40,240,0.1);}

.qrio-target {color: #34c; text-decoration: none; cursor: pointer;}
.qrio-target::after {content: '\29c9'; font-size:125%; padding:0 0.5em; position: relative; top: 0.2em;}

/* viewers */
.qrio-imgwrap {
  position: absolute;
  left: 0.5em; top: 2.5em; right: 0.5em; bottom: 2.5em; margin: auto auto;
}
@media all and (orientation:landscape) {
  .qrio-imgwrap {top: 4.5em;}
}
.qrio-imgwrap.qrio-scroll {
  overflow-y: auto; top: 8em; bottom: 2.2em;
}
@media all and (max-width:540px) {
  .qrio-imgwrap.qrio-scroll {top: 6.5em;}
}
@media all and (orientation:landscape) {
  .qrio-imgwrap.qrio-scroll {top: 6.3em;}
}
@media all and (min-width:520px) {
  .qrio-imgwrap {left: 60px; right: 60px;}
}
@media all and (min-width:720px) {
  .qrio-imgwrap {left: 120px; right: 120px;}
  .qrio-imgwrap.scroll {max-width: 500px;}
}
.qrio-img {
  position: absolute;
  left: 0; top: 0; right: 0; bottom: 0; width: 100%;
}
.qrio-img.qrio-closed {display: none;}
.qrio-img.qrio-fitted {
  width: auto; max-width: 100%; max-height: 100%; margin: auto auto;
}

/* svg overlay */
.qrio-overlay > .qrio-extracted {stroke: red; stroke-width: 1;}
@media all and (max-width:700px) {
  .qrio-overlay > .qrio-extracted {stroke-width: 1;}
}
.qrio-overlay > .qrio-extracted         {fill: rgba(75,240,40,0.2);}
.qrio-overlay > .qrio-extracted.qrio-c1 {fill: rgba(240,140,20,0.2);}
.qrio-overlay > .qrio-extracted.qrio-c2 {fill: rgba(240,240,40,0.25);}
.qrio-overlay > .qrio-extracted.qrio-c3 {fill: rgba(40,40,240,0.133);}
.qrio-overlay > .qrio-extracted.qrio-c4 {fill: rgba(240,40,240,0.133);}

/* specific styles */
#qrio-generator-status {display: inline-block; max-width: 75%; white-space: nowrap; padding: 0.3em 0.4em;}
#qrio-reader-status {margin-top: 3em;}

#qrio-reader-camerainput {display: none;}
#qrio-reader-camerainputlabel {
  position: absolute; top: 0; left: 0;  
  font-size: 95%; font-family: sans-serif; cursor: pointer;
  padding: 3px 6px; border: 1px solid green; border-radius: 0.2em; margin-right: 0.3em;
}
#qrio-reader-camerainputlabel:active, #qrio-reader-camerainputlabel:hover {
  background-color: #ded;
}
#qrio-reader-fileinput {
  position: absolute; bottom: 0.5em; left: 0.5em; max-width: 95%; border: 0; 
  font-size: 85%; font-family: sans-serif; background-color: rgba(235,235,235,0.8);
}
#qrio-reader-fileinput::file-selector-button {
}
  </style>

  <!-- styles specific to page -->
  <style>
    body {font-family: sans-serif; font-size: 98%;}
    .index {margin: 0.2em 0.2em;}
    @media all and (orientation:landscape) {
      .index {margin: 1.5em 1.5em;}
    }
    button {cursor: pointer;}
    .clickable {cursor: pointer; margin-top: 2em; color: #35b;}
    .clickable:hover, .clickable:active {color: #ff6666;}
    .index > .chk {display: inline-block; margin-top: 1.2em;}
    .index > .chklabel {font-size: 85%;}
    .index > textarea {
      width: 97%; height:10em; margin-top: 1.5em; border: 1px solid #ccc; 
      font-family: monospace; font-size: 105%;
    }
    .index > .tiny {font-size: 75%; margin-top: 2.5em;}
  </style>

  <!--
  These are for optional BarcodeDetector polyfill (to support detection in all browsers)
    (a license may be required, check their website)
  <script src="https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@9.0.2/dist/dbr.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/barcode-detection@0.4.0/dist/barcode-detector.umd.js"></script>
  <script src="https://unpkg.com/eruda@2.4.1/eruda.js"></script>
  <script>eruda.init();</script>
  -->

  <!-- <script type="text/javascript" src="lib/qrcode.js"></script> -->
  <script>
//---------------------------------------------------------------------
//
// QR Code Generator for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//  http://www.opensource.org/licenses/mit-license.php
//
// The word 'QR Code' is registered trademark of
// DENSO WAVE INCORPORATED
//  http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------

var qrcode = function() {

  //---------------------------------------------------------------------
  // qrcode
  //---------------------------------------------------------------------

  /**
   * qrcode
   * @param typeNumber 1 to 40
   * @param errorCorrectionLevel 'L','M','Q','H'
   */
  var qrcode = function(typeNumber, errorCorrectionLevel) {

    var PAD0 = 0xEC;
    var PAD1 = 0x11;

    var _typeNumber = typeNumber;
    var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
    var _modules = null;
    var _moduleCount = 0;
    var _dataCache = null;
    var _dataList = [];

    var _this = {};

    var makeImpl = function(test, maskPattern) {

      _moduleCount = _typeNumber * 4 + 17;
      _modules = function(moduleCount) {
        var modules = new Array(moduleCount);
        for (var row = 0; row < moduleCount; row += 1) {
          modules[row] = new Array(moduleCount);
          for (var col = 0; col < moduleCount; col += 1) {
            modules[row][col] = null;
          }
        }
        return modules;
      }(_moduleCount);

      setupPositionProbePattern(0, 0);
      setupPositionProbePattern(_moduleCount - 7, 0);
      setupPositionProbePattern(0, _moduleCount - 7);
      setupPositionAdjustPattern();
      setupTimingPattern();
      setupTypeInfo(test, maskPattern);

      if (_typeNumber >= 7) {
        setupTypeNumber(test);
      }

      if (_dataCache == null) {
        _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
      }

      mapData(_dataCache, maskPattern);
    };

    var setupPositionProbePattern = function(row, col) {

      for (var r = -1; r <= 7; r += 1) {

        if (row + r <= -1 || _moduleCount <= row + r) continue;

        for (var c = -1; c <= 7; c += 1) {

          if (col + c <= -1 || _moduleCount <= col + c) continue;

          if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
              || (0 <= c && c <= 6 && (r == 0 || r == 6) )
              || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
            _modules[row + r][col + c] = true;
          } else {
            _modules[row + r][col + c] = false;
          }
        }
      }
    };

    var getBestMaskPattern = function() {

      var minLostPoint = 0;
      var pattern = 0;

      for (var i = 0; i < 8; i += 1) {

        makeImpl(true, i);

        var lostPoint = QRUtil.getLostPoint(_this);

        if (i == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i;
        }
      }

      return pattern;
    };

    var setupTimingPattern = function() {

      for (var r = 8; r < _moduleCount - 8; r += 1) {
        if (_modules[r][6] != null) {
          continue;
        }
        _modules[r][6] = (r % 2 == 0);
      }

      for (var c = 8; c < _moduleCount - 8; c += 1) {
        if (_modules[6][c] != null) {
          continue;
        }
        _modules[6][c] = (c % 2 == 0);
      }
    };

    var setupPositionAdjustPattern = function() {

      var pos = QRUtil.getPatternPosition(_typeNumber);

      for (var i = 0; i < pos.length; i += 1) {

        for (var j = 0; j < pos.length; j += 1) {

          var row = pos[i];
          var col = pos[j];

          if (_modules[row][col] != null) {
            continue;
          }

          for (var r = -2; r <= 2; r += 1) {

            for (var c = -2; c <= 2; c += 1) {

              if (r == -2 || r == 2 || c == -2 || c == 2
                  || (r == 0 && c == 0) ) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        }
      }
    };

    var setupTypeNumber = function(test) {

      var bits = QRUtil.getBCHTypeNumber(_typeNumber);

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
      }

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    };

    var setupTypeInfo = function(test, maskPattern) {

      var data = (_errorCorrectionLevel << 3) | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);

      // vertical
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 6) {
          _modules[i][8] = mod;
        } else if (i < 8) {
          _modules[i + 1][8] = mod;
        } else {
          _modules[_moduleCount - 15 + i][8] = mod;
        }
      }

      // horizontal
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 8) {
          _modules[8][_moduleCount - i - 1] = mod;
        } else if (i < 9) {
          _modules[8][15 - i - 1 + 1] = mod;
        } else {
          _modules[8][15 - i - 1] = mod;
        }
      }

      // fixed module
      _modules[_moduleCount - 8][8] = (!test);
    };

    var mapData = function(data, maskPattern) {

      var inc = -1;
      var row = _moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      var maskFunc = QRUtil.getMaskFunction(maskPattern);

      for (var col = _moduleCount - 1; col > 0; col -= 2) {

        if (col == 6) col -= 1;

        while (true) {

          for (var c = 0; c < 2; c += 1) {

            if (_modules[row][col - c] == null) {

              var dark = false;

              if (byteIndex < data.length) {
                dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
              }

              var mask = maskFunc(row, col - c);

              if (mask) {
                dark = !dark;
              }

              _modules[row][col - c] = dark;
              bitIndex -= 1;

              if (bitIndex == -1) {
                byteIndex += 1;
                bitIndex = 7;
              }
            }
          }

          row += inc;

          if (row < 0 || _moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    };

    var createBytes = function(buffer, rsBlocks) {

      var offset = 0;

      var maxDcCount = 0;
      var maxEcCount = 0;

      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);

      for (var r = 0; r < rsBlocks.length; r += 1) {

        var dcCount = rsBlocks[r].dataCount;
        var ecCount = rsBlocks[r].totalCount - dcCount;

        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);

        dcdata[r] = new Array(dcCount);

        for (var i = 0; i < dcdata[r].length; i += 1) {
          dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
        }
        offset += dcCount;

        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);

        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r] = new Array(rsPoly.getLength() - 1);
        for (var i = 0; i < ecdata[r].length; i += 1) {
          var modIndex = i + modPoly.getLength() - ecdata[r].length;
          ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;
        }
      }

      var totalCodeCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalCodeCount += rsBlocks[i].totalCount;
      }

      var data = new Array(totalCodeCount);
      var index = 0;

      for (var i = 0; i < maxDcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < dcdata[r].length) {
            data[index] = dcdata[r][i];
            index += 1;
          }
        }
      }

      for (var i = 0; i < maxEcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < ecdata[r].length) {
            data[index] = ecdata[r][i];
            index += 1;
          }
        }
      }

      return data;
    };

    var createData = function(typeNumber, errorCorrectionLevel, dataList) {

      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);

      var buffer = qrBitBuffer();

      for (var i = 0; i < dataList.length; i += 1) {
        var data = dataList[i];
        buffer.put(data.getMode(), 4);
        buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
        data.write(buffer);
      }

      // calc num max data.
      var totalDataCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalDataCount += rsBlocks[i].dataCount;
      }

      if (buffer.getLengthInBits() > totalDataCount * 8) {
        throw 'code length overflow. ('
          + buffer.getLengthInBits()
          + '>'
          + totalDataCount * 8
          + ')';
      }

      // end code
      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer.put(0, 4);
      }

      // padding
      while (buffer.getLengthInBits() % 8 != 0) {
        buffer.putBit(false);
      }

      // padding
      while (true) {

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD0, 8);

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD1, 8);
      }

      return createBytes(buffer, rsBlocks);
    };

    _this.addData = function(data, mode) {

      mode = mode || 'Byte';

      var newData = null;

      switch(mode) {
      case 'Numeric' :
        newData = qrNumber(data);
        break;
      case 'Alphanumeric' :
        newData = qrAlphaNum(data);
        break;
      case 'Byte' :
        newData = qr8BitByte(data);
        break;
      case 'Kanji' :
        newData = qrKanji(data);
        break;
      default :
        throw 'mode:' + mode;
      }

      _dataList.push(newData);
      _dataCache = null;
    };

    _this.isDark = function(row, col) {
      if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
        throw row + ',' + col;
      }
      return _modules[row][col];
    };

    _this.getModuleCount = function() {
      return _moduleCount;
    };

    _this.make = function() {
      if (_typeNumber < 1) {
        var typeNumber = 1;

        for (; typeNumber < 40; typeNumber++) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, _errorCorrectionLevel);
          var buffer = qrBitBuffer();

          for (var i = 0; i < _dataList.length; i++) {
            var data = _dataList[i];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
            data.write(buffer);
          }

          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
          }

          if (buffer.getLengthInBits() <= totalDataCount * 8) {
            break;
          }
        }

        _typeNumber = typeNumber;
      }

      makeImpl(false, getBestMaskPattern() );
    };

    _this.createTableTag = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var qrHtml = '';

      qrHtml += '<table style="';
      qrHtml += ' border-width: 0px; border-style: none;';
      qrHtml += ' border-collapse: collapse;';
      qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
      qrHtml += '">';
      qrHtml += '<tbody>';

      for (var r = 0; r < _this.getModuleCount(); r += 1) {

        qrHtml += '<tr>';

        for (var c = 0; c < _this.getModuleCount(); c += 1) {
          qrHtml += '<td style="';
          qrHtml += ' border-width: 0px; border-style: none;';
          qrHtml += ' border-collapse: collapse;';
          qrHtml += ' padding: 0px; margin: 0px;';
          qrHtml += ' width: ' + cellSize + 'px;';
          qrHtml += ' height: ' + cellSize + 'px;';
          qrHtml += ' background-color: ';
          qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';
          qrHtml += ';';
          qrHtml += '"/>';
        }

        qrHtml += '</tr>';
      }

      qrHtml += '</tbody>';
      qrHtml += '</table>';

      return qrHtml;
    };

    _this.createSvgTag = function(cellSize, margin, alt, title) {

      var opts = {};
      if (typeof arguments[0] == 'object') {
        // Called by options.
        opts = arguments[0];
        // overwrite cellSize and margin.
        cellSize = opts.cellSize;
        margin = opts.margin;
        alt = opts.alt;
        title = opts.title;
      }

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      // Compose alt property surrogate
      alt = (typeof alt === 'string') ? {text: alt} : alt || {};
      alt.text = alt.text || null;
      alt.id = (alt.text) ? alt.id || 'qrcode-description' : null;

      // Compose title property surrogate
      title = (typeof title === 'string') ? {text: title} : title || {};
      title.text = title.text || null;
      title.id = (title.text) ? title.id || 'qrcode-title' : null;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var c, mc, r, mr, qrSvg='', rect;

      rect = 'l' + cellSize + ',0 0,' + cellSize +
        ' -' + cellSize + ',0 0,-' + cellSize + 'z ';

      qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
      qrSvg += !opts.scalable ? ' width="' + size + 'px" height="' + size + 'px"' : '';
      qrSvg += ' viewBox="0 0 ' + size + ' ' + size + '" ';
      qrSvg += ' preserveAspectRatio="xMinYMin meet"';
      qrSvg += (title.text || alt.text) ? ' role="img" aria-labelledby="' +
          escapeXml([title.id, alt.id].join(' ').trim() ) + '"' : '';
      qrSvg += '>';
      qrSvg += (title.text) ? '<title id="' + escapeXml(title.id) + '">' +
          escapeXml(title.text) + '</title>' : '';
      qrSvg += (alt.text) ? '<description id="' + escapeXml(alt.id) + '">' +
          escapeXml(alt.text) + '</description>' : '';
      qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
      qrSvg += '<path d="';

      for (r = 0; r < _this.getModuleCount(); r += 1) {
        mr = r * cellSize + margin;
        for (c = 0; c < _this.getModuleCount(); c += 1) {
          if (_this.isDark(r, c) ) {
            mc = c*cellSize+margin;
            qrSvg += 'M' + mc + ',' + mr + rect;
          }
        }
      }

      qrSvg += '" stroke="transparent" fill="black"/>';
      qrSvg += '</svg>';

      return qrSvg;
    };

    _this.createDataURL = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      return createDataURL(size, size, function(x, y) {
        if (min <= x && x < max && min <= y && y < max) {
          var c = Math.floor( (x - min) / cellSize);
          var r = Math.floor( (y - min) / cellSize);
          return _this.isDark(r, c)? 0 : 1;
        } else {
          return 1;
        }
      } );
    };

    _this.createImgTag = function(cellSize, margin, alt) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;

      var img = '';
      img += '<img';
      img += '\u0020src="';
      img += _this.createDataURL(cellSize, margin);
      img += '"';
      img += '\u0020width="';
      img += size;
      img += '"';
      img += '\u0020height="';
      img += size;
      img += '"';
      if (alt) {
        img += '\u0020alt="';
        img += escapeXml(alt);
        img += '"';
      }
      img += '/>';

      return img;
    };

    var escapeXml = function(s) {
      var escaped = '';
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charAt(i);
        switch(c) {
        case '<': escaped += '&lt;'; break;
        case '>': escaped += '&gt;'; break;
        case '&': escaped += '&amp;'; break;
        case '"': escaped += '&quot;'; break;
        default : escaped += c; break;
        }
      }
      return escaped;
    };

    var _createHalfASCII = function(margin) {
      var cellSize = 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r1, r2, p;

      var blocks = {
        '██': '█',
        '█ ': '▀',
        ' █': '▄',
        '  ': ' '
      };

      var blocksLastLineNoMargin = {
        '██': '▀',
        '█ ': '▀',
        ' █': ' ',
        '  ': ' '
      };

      var ascii = '';
      for (y = 0; y < size; y += 2) {
        r1 = Math.floor((y - min) / cellSize);
        r2 = Math.floor((y + 1 - min) / cellSize);
        for (x = 0; x < size; x += 1) {
          p = '█';

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r1, Math.floor((x - min) / cellSize))) {
            p = ' ';
          }

          if (min <= x && x < max && min <= y+1 && y+1 < max && _this.isDark(r2, Math.floor((x - min) / cellSize))) {
            p += ' ';
          }
          else {
            p += '█';
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          ascii += (margin < 1 && y+1 >= max) ? blocksLastLineNoMargin[p] : blocks[p];
        }

        ascii += '\n';
      }

      if (size % 2 && margin > 0) {
        return ascii.substring(0, ascii.length - size - 1) + Array(size+1).join('▀');
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.createASCII = function(cellSize, margin) {
      cellSize = cellSize || 1;

      if (cellSize < 2) {
        return _createHalfASCII(margin);
      }

      cellSize -= 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r, p;

      var white = Array(cellSize+1).join('██');
      var black = Array(cellSize+1).join('  ');

      var ascii = '';
      var line = '';
      for (y = 0; y < size; y += 1) {
        r = Math.floor( (y - min) / cellSize);
        line = '';
        for (x = 0; x < size; x += 1) {
          p = 1;

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r, Math.floor((x - min) / cellSize))) {
            p = 0;
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          line += p ? white : black;
        }

        for (r = 0; r < cellSize; r += 1) {
          ascii += line + '\n';
        }
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.renderTo2dContext = function(context, cellSize) {
      cellSize = cellSize || 2;
      var length = _this.getModuleCount();
      for (var row = 0; row < length; row++) {
        for (var col = 0; col < length; col++) {
          context.fillStyle = _this.isDark(row, col) ? 'black' : 'white';
          context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
        }
      }
    }

    return _this;
  };

  //---------------------------------------------------------------------
  // qrcode.stringToBytes
  //---------------------------------------------------------------------

  qrcode.stringToBytesFuncs = {
    'default' : function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        bytes.push(c & 0xff);
      }
      return bytes;
    }
  };

  qrcode.stringToBytes = qrcode.stringToBytesFuncs['default'];

  //---------------------------------------------------------------------
  // qrcode.createStringToBytes
  //---------------------------------------------------------------------

  /**
   * @param unicodeData base64 string of byte array.
   * [16bit Unicode],[16bit Bytes], ...
   * @param numChars
   */
  qrcode.createStringToBytes = function(unicodeData, numChars) {

    // create conversion map.

    var unicodeMap = function() {

      var bin = base64DecodeInputStream(unicodeData);
      var read = function() {
        var b = bin.read();
        if (b == -1) throw 'eof';
        return b;
      };

      var count = 0;
      var unicodeMap = {};
      while (true) {
        var b0 = bin.read();
        if (b0 == -1) break;
        var b1 = read();
        var b2 = read();
        var b3 = read();
        var k = String.fromCharCode( (b0 << 8) | b1);
        var v = (b2 << 8) | b3;
        unicodeMap[k] = v;
        count += 1;
      }
      if (count != numChars) {
        throw count + ' != ' + numChars;
      }

      return unicodeMap;
    }();

    var unknownChar = '?'.charCodeAt(0);

    return function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        if (c < 128) {
          bytes.push(c);
        } else {
          var b = unicodeMap[s.charAt(i)];
          if (typeof b == 'number') {
            if ( (b & 0xff) == b) {
              // 1byte
              bytes.push(b);
            } else {
              // 2bytes
              bytes.push(b >>> 8);
              bytes.push(b & 0xff);
            }
          } else {
            bytes.push(unknownChar);
          }
        }
      }
      return bytes;
    };
  };

  //---------------------------------------------------------------------
  // QRMode
  //---------------------------------------------------------------------

  var QRMode = {
    MODE_NUMBER :    1 << 0,
    MODE_ALPHA_NUM : 1 << 1,
    MODE_8BIT_BYTE : 1 << 2,
    MODE_KANJI :     1 << 3
  };

  //---------------------------------------------------------------------
  // QRErrorCorrectionLevel
  //---------------------------------------------------------------------

  var QRErrorCorrectionLevel = {
    L : 1,
    M : 0,
    Q : 3,
    H : 2
  };

  //---------------------------------------------------------------------
  // QRMaskPattern
  //---------------------------------------------------------------------

  var QRMaskPattern = {
    PATTERN000 : 0,
    PATTERN001 : 1,
    PATTERN010 : 2,
    PATTERN011 : 3,
    PATTERN100 : 4,
    PATTERN101 : 5,
    PATTERN110 : 6,
    PATTERN111 : 7
  };

  //---------------------------------------------------------------------
  // QRUtil
  //---------------------------------------------------------------------

  var QRUtil = function() {

    var PATTERN_POSITION_TABLE = [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ];
    var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
    var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
    var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);

    var _this = {};

    var getBCHDigit = function(data) {
      var digit = 0;
      while (data != 0) {
        digit += 1;
        data >>>= 1;
      }
      return digit;
    };

    _this.getBCHTypeInfo = function(data) {
      var d = data << 10;
      while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
        d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
      }
      return ( (data << 10) | d) ^ G15_MASK;
    };

    _this.getBCHTypeNumber = function(data) {
      var d = data << 12;
      while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
        d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
      }
      return (data << 12) | d;
    };

    _this.getPatternPosition = function(typeNumber) {
      return PATTERN_POSITION_TABLE[typeNumber - 1];
    };

    _this.getMaskFunction = function(maskPattern) {

      switch (maskPattern) {

      case QRMaskPattern.PATTERN000 :
        return function(i, j) { return (i + j) % 2 == 0; };
      case QRMaskPattern.PATTERN001 :
        return function(i, j) { return i % 2 == 0; };
      case QRMaskPattern.PATTERN010 :
        return function(i, j) { return j % 3 == 0; };
      case QRMaskPattern.PATTERN011 :
        return function(i, j) { return (i + j) % 3 == 0; };
      case QRMaskPattern.PATTERN100 :
        return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
      case QRMaskPattern.PATTERN101 :
        return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
      case QRMaskPattern.PATTERN110 :
        return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
      case QRMaskPattern.PATTERN111 :
        return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };

      default :
        throw 'bad maskPattern:' + maskPattern;
      }
    };

    _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
      var a = qrPolynomial([1], 0);
      for (var i = 0; i < errorCorrectLength; i += 1) {
        a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
      }
      return a;
    };

    _this.getLengthInBits = function(mode, type) {

      if (1 <= type && type < 10) {

        // 1 - 9

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 10;
        case QRMode.MODE_ALPHA_NUM : return 9;
        case QRMode.MODE_8BIT_BYTE : return 8;
        case QRMode.MODE_KANJI     : return 8;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 27) {

        // 10 - 26

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 12;
        case QRMode.MODE_ALPHA_NUM : return 11;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 10;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 41) {

        // 27 - 40

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 14;
        case QRMode.MODE_ALPHA_NUM : return 13;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 12;
        default :
          throw 'mode:' + mode;
        }

      } else {
        throw 'type:' + type;
      }
    };

    _this.getLostPoint = function(qrcode) {

      var moduleCount = qrcode.getModuleCount();

      var lostPoint = 0;

      // LEVEL1

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount; col += 1) {

          var sameCount = 0;
          var dark = qrcode.isDark(row, col);

          for (var r = -1; r <= 1; r += 1) {

            if (row + r < 0 || moduleCount <= row + r) {
              continue;
            }

            for (var c = -1; c <= 1; c += 1) {

              if (col + c < 0 || moduleCount <= col + c) {
                continue;
              }

              if (r == 0 && c == 0) {
                continue;
              }

              if (dark == qrcode.isDark(row + r, col + c) ) {
                sameCount += 1;
              }
            }
          }

          if (sameCount > 5) {
            lostPoint += (3 + sameCount - 5);
          }
        }
      };

      // LEVEL2

      for (var row = 0; row < moduleCount - 1; row += 1) {
        for (var col = 0; col < moduleCount - 1; col += 1) {
          var count = 0;
          if (qrcode.isDark(row, col) ) count += 1;
          if (qrcode.isDark(row + 1, col) ) count += 1;
          if (qrcode.isDark(row, col + 1) ) count += 1;
          if (qrcode.isDark(row + 1, col + 1) ) count += 1;
          if (count == 0 || count == 4) {
            lostPoint += 3;
          }
        }
      }

      // LEVEL3

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount - 6; col += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row, col + 1)
              &&  qrcode.isDark(row, col + 2)
              &&  qrcode.isDark(row, col + 3)
              &&  qrcode.isDark(row, col + 4)
              && !qrcode.isDark(row, col + 5)
              &&  qrcode.isDark(row, col + 6) ) {
            lostPoint += 40;
          }
        }
      }

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount - 6; row += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row + 1, col)
              &&  qrcode.isDark(row + 2, col)
              &&  qrcode.isDark(row + 3, col)
              &&  qrcode.isDark(row + 4, col)
              && !qrcode.isDark(row + 5, col)
              &&  qrcode.isDark(row + 6, col) ) {
            lostPoint += 40;
          }
        }
      }

      // LEVEL4

      var darkCount = 0;

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount; row += 1) {
          if (qrcode.isDark(row, col) ) {
            darkCount += 1;
          }
        }
      }

      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;

      return lostPoint;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // QRMath
  //---------------------------------------------------------------------

  var QRMath = function() {

    var EXP_TABLE = new Array(256);
    var LOG_TABLE = new Array(256);

    // initialize tables
    for (var i = 0; i < 8; i += 1) {
      EXP_TABLE[i] = 1 << i;
    }
    for (var i = 8; i < 256; i += 1) {
      EXP_TABLE[i] = EXP_TABLE[i - 4]
        ^ EXP_TABLE[i - 5]
        ^ EXP_TABLE[i - 6]
        ^ EXP_TABLE[i - 8];
    }
    for (var i = 0; i < 255; i += 1) {
      LOG_TABLE[EXP_TABLE[i] ] = i;
    }

    var _this = {};

    _this.glog = function(n) {

      if (n < 1) {
        throw 'glog(' + n + ')';
      }

      return LOG_TABLE[n];
    };

    _this.gexp = function(n) {

      while (n < 0) {
        n += 255;
      }

      while (n >= 256) {
        n -= 255;
      }

      return EXP_TABLE[n];
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrPolynomial
  //---------------------------------------------------------------------

  function qrPolynomial(num, shift) {

    if (typeof num.length == 'undefined') {
      throw num.length + '/' + shift;
    }

    var _num = function() {
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset += 1;
      }
      var _num = new Array(num.length - offset + shift);
      for (var i = 0; i < num.length - offset; i += 1) {
        _num[i] = num[i + offset];
      }
      return _num;
    }();

    var _this = {};

    _this.getAt = function(index) {
      return _num[index];
    };

    _this.getLength = function() {
      return _num.length;
    };

    _this.multiply = function(e) {

      var num = new Array(_this.getLength() + e.getLength() - 1);

      for (var i = 0; i < _this.getLength(); i += 1) {
        for (var j = 0; j < e.getLength(); j += 1) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );
        }
      }

      return qrPolynomial(num, 0);
    };

    _this.mod = function(e) {

      if (_this.getLength() - e.getLength() < 0) {
        return _this;
      }

      var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );

      var num = new Array(_this.getLength() );
      for (var i = 0; i < _this.getLength(); i += 1) {
        num[i] = _this.getAt(i);
      }

      for (var i = 0; i < e.getLength(); i += 1) {
        num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);
      }

      // recursive call
      return qrPolynomial(num, 0).mod(e);
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // QRRSBlock
  //---------------------------------------------------------------------

  var QRRSBlock = function() {

    var RS_BLOCK_TABLE = [

      // L
      // M
      // Q
      // H

      // 1
      [1, 26, 19],
      [1, 26, 16],
      [1, 26, 13],
      [1, 26, 9],

      // 2
      [1, 44, 34],
      [1, 44, 28],
      [1, 44, 22],
      [1, 44, 16],

      // 3
      [1, 70, 55],
      [1, 70, 44],
      [2, 35, 17],
      [2, 35, 13],

      // 4
      [1, 100, 80],
      [2, 50, 32],
      [2, 50, 24],
      [4, 25, 9],

      // 5
      [1, 134, 108],
      [2, 67, 43],
      [2, 33, 15, 2, 34, 16],
      [2, 33, 11, 2, 34, 12],

      // 6
      [2, 86, 68],
      [4, 43, 27],
      [4, 43, 19],
      [4, 43, 15],

      // 7
      [2, 98, 78],
      [4, 49, 31],
      [2, 32, 14, 4, 33, 15],
      [4, 39, 13, 1, 40, 14],

      // 8
      [2, 121, 97],
      [2, 60, 38, 2, 61, 39],
      [4, 40, 18, 2, 41, 19],
      [4, 40, 14, 2, 41, 15],

      // 9
      [2, 146, 116],
      [3, 58, 36, 2, 59, 37],
      [4, 36, 16, 4, 37, 17],
      [4, 36, 12, 4, 37, 13],

      // 10
      [2, 86, 68, 2, 87, 69],
      [4, 69, 43, 1, 70, 44],
      [6, 43, 19, 2, 44, 20],
      [6, 43, 15, 2, 44, 16],

      // 11
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],

      // 12
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],

      // 13
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],

      // 14
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],

      // 15
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12, 7, 37, 13],

      // 16
      [5, 122, 98, 1, 123, 99],
      [7, 73, 45, 3, 74, 46],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],

      // 17
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],

      // 18
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],

      // 19
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],

      // 20
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],

      // 21
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],

      // 22
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],

      // 23
      [4, 151, 121, 5, 152, 122],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],

      // 24
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],

      // 25
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],

      // 26
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],

      // 27
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],

      // 28
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],

      // 29
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],

      // 30
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],

      // 31
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],

      // 32
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],

      // 33
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],

      // 34
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],

      // 35
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],

      // 36
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],

      // 37
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],

      // 38
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],

      // 39
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],

      // 40
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]
    ];

    var qrRSBlock = function(totalCount, dataCount) {
      var _this = {};
      _this.totalCount = totalCount;
      _this.dataCount = dataCount;
      return _this;
    };

    var _this = {};

    var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {

      switch(errorCorrectionLevel) {
      case QRErrorCorrectionLevel.L :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case QRErrorCorrectionLevel.M :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case QRErrorCorrectionLevel.Q :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case QRErrorCorrectionLevel.H :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default :
        return undefined;
      }
    };

    _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {

      var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);

      if (typeof rsBlock == 'undefined') {
        throw 'bad rs block @ typeNumber:' + typeNumber +
            '/errorCorrectionLevel:' + errorCorrectionLevel;
      }

      var length = rsBlock.length / 3;

      var list = [];

      for (var i = 0; i < length; i += 1) {

        var count = rsBlock[i * 3 + 0];
        var totalCount = rsBlock[i * 3 + 1];
        var dataCount = rsBlock[i * 3 + 2];

        for (var j = 0; j < count; j += 1) {
          list.push(qrRSBlock(totalCount, dataCount) );
        }
      }

      return list;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrBitBuffer
  //---------------------------------------------------------------------

  var qrBitBuffer = function() {

    var _buffer = [];
    var _length = 0;

    var _this = {};

    _this.getBuffer = function() {
      return _buffer;
    };

    _this.getAt = function(index) {
      var bufIndex = Math.floor(index / 8);
      return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
    };

    _this.put = function(num, length) {
      for (var i = 0; i < length; i += 1) {
        _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
      }
    };

    _this.getLengthInBits = function() {
      return _length;
    };

    _this.putBit = function(bit) {

      var bufIndex = Math.floor(_length / 8);
      if (_buffer.length <= bufIndex) {
        _buffer.push(0);
      }

      if (bit) {
        _buffer[bufIndex] |= (0x80 >>> (_length % 8) );
      }

      _length += 1;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrNumber
  //---------------------------------------------------------------------

  var qrNumber = function(data) {

    var _mode = QRMode.MODE_NUMBER;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var data = _data;

      var i = 0;

      while (i + 2 < data.length) {
        buffer.put(strToNum(data.substring(i, i + 3) ), 10);
        i += 3;
      }

      if (i < data.length) {
        if (data.length - i == 1) {
          buffer.put(strToNum(data.substring(i, i + 1) ), 4);
        } else if (data.length - i == 2) {
          buffer.put(strToNum(data.substring(i, i + 2) ), 7);
        }
      }
    };

    var strToNum = function(s) {
      var num = 0;
      for (var i = 0; i < s.length; i += 1) {
        num = num * 10 + chatToNum(s.charAt(i) );
      }
      return num;
    };

    var chatToNum = function(c) {
      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      }
      throw 'illegal char :' + c;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrAlphaNum
  //---------------------------------------------------------------------

  var qrAlphaNum = function(data) {

    var _mode = QRMode.MODE_ALPHA_NUM;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var s = _data;

      var i = 0;

      while (i + 1 < s.length) {
        buffer.put(
          getCode(s.charAt(i) ) * 45 +
          getCode(s.charAt(i + 1) ), 11);
        i += 2;
      }

      if (i < s.length) {
        buffer.put(getCode(s.charAt(i) ), 6);
      }
    };

    var getCode = function(c) {

      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      } else if ('A' <= c && c <= 'Z') {
        return c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
      } else {
        switch (c) {
        case ' ' : return 36;
        case '$' : return 37;
        case '%' : return 38;
        case '*' : return 39;
        case '+' : return 40;
        case '-' : return 41;
        case '.' : return 42;
        case '/' : return 43;
        case ':' : return 44;
        default :
          throw 'illegal char :' + c;
        }
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qr8BitByte
  //---------------------------------------------------------------------

  var qr8BitByte = function(data) {

    var _mode = QRMode.MODE_8BIT_BYTE;
    var _data = data;
    var _bytes = qrcode.stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _bytes.length;
    };

    _this.write = function(buffer) {
      for (var i = 0; i < _bytes.length; i += 1) {
        buffer.put(_bytes[i], 8);
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrKanji
  //---------------------------------------------------------------------

  var qrKanji = function(data) {

    var _mode = QRMode.MODE_KANJI;
    var _data = data;

    var stringToBytes = qrcode.stringToBytesFuncs['SJIS'];
    if (!stringToBytes) {
      throw 'sjis not supported.';
    }
    !function(c, code) {
      // self test for sjis support.
      var test = stringToBytes(c);
      if (test.length != 2 || ( (test[0] << 8) | test[1]) != code) {
        throw 'sjis not supported.';
      }
    }('\u53cb', 0x9746);

    var _bytes = stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return ~~(_bytes.length / 2);
    };

    _this.write = function(buffer) {

      var data = _bytes;

      var i = 0;

      while (i + 1 < data.length) {

        var c = ( (0xff & data[i]) << 8) | (0xff & data[i + 1]);

        if (0x8140 <= c && c <= 0x9FFC) {
          c -= 0x8140;
        } else if (0xE040 <= c && c <= 0xEBBF) {
          c -= 0xC140;
        } else {
          throw 'illegal char at ' + (i + 1) + '/' + c;
        }

        c = ( (c >>> 8) & 0xff) * 0xC0 + (c & 0xff);

        buffer.put(c, 13);

        i += 2;
      }

      if (i < data.length) {
        throw 'illegal char at ' + (i + 1);
      }
    };

    return _this;
  };

  //=====================================================================
  // GIF Support etc.
  //

  //---------------------------------------------------------------------
  // byteArrayOutputStream
  //---------------------------------------------------------------------

  var byteArrayOutputStream = function() {

    var _bytes = [];

    var _this = {};

    _this.writeByte = function(b) {
      _bytes.push(b & 0xff);
    };

    _this.writeShort = function(i) {
      _this.writeByte(i);
      _this.writeByte(i >>> 8);
    };

    _this.writeBytes = function(b, off, len) {
      off = off || 0;
      len = len || b.length;
      for (var i = 0; i < len; i += 1) {
        _this.writeByte(b[i + off]);
      }
    };

    _this.writeString = function(s) {
      for (var i = 0; i < s.length; i += 1) {
        _this.writeByte(s.charCodeAt(i) );
      }
    };

    _this.toByteArray = function() {
      return _bytes;
    };

    _this.toString = function() {
      var s = '';
      s += '[';
      for (var i = 0; i < _bytes.length; i += 1) {
        if (i > 0) {
          s += ',';
        }
        s += _bytes[i];
      }
      s += ']';
      return s;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64EncodeOutputStream
  //---------------------------------------------------------------------

  var base64EncodeOutputStream = function() {

    var _buffer = 0;
    var _buflen = 0;
    var _length = 0;
    var _base64 = '';

    var _this = {};

    var writeEncoded = function(b) {
      _base64 += String.fromCharCode(encode(b & 0x3f) );
    };

    var encode = function(n) {
      if (n < 0) {
        // error.
      } else if (n < 26) {
        return 0x41 + n;
      } else if (n < 52) {
        return 0x61 + (n - 26);
      } else if (n < 62) {
        return 0x30 + (n - 52);
      } else if (n == 62) {
        return 0x2b;
      } else if (n == 63) {
        return 0x2f;
      }
      throw 'n:' + n;
    };

    _this.writeByte = function(n) {

      _buffer = (_buffer << 8) | (n & 0xff);
      _buflen += 8;
      _length += 1;

      while (_buflen >= 6) {
        writeEncoded(_buffer >>> (_buflen - 6) );
        _buflen -= 6;
      }
    };

    _this.flush = function() {

      if (_buflen > 0) {
        writeEncoded(_buffer << (6 - _buflen) );
        _buffer = 0;
        _buflen = 0;
      }

      if (_length % 3 != 0) {
        // padding
        var padlen = 3 - _length % 3;
        for (var i = 0; i < padlen; i += 1) {
          _base64 += '=';
        }
      }
    };

    _this.toString = function() {
      return _base64;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64DecodeInputStream
  //---------------------------------------------------------------------

  var base64DecodeInputStream = function(str) {

    var _str = str;
    var _pos = 0;
    var _buffer = 0;
    var _buflen = 0;

    var _this = {};

    _this.read = function() {

      while (_buflen < 8) {

        if (_pos >= _str.length) {
          if (_buflen == 0) {
            return -1;
          }
          throw 'unexpected end of file./' + _buflen;
        }

        var c = _str.charAt(_pos);
        _pos += 1;

        if (c == '=') {
          _buflen = 0;
          return -1;
        } else if (c.match(/^\s$/) ) {
          // ignore if whitespace.
          continue;
        }

        _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
        _buflen += 6;
      }

      var n = (_buffer >>> (_buflen - 8) ) & 0xff;
      _buflen -= 8;
      return n;
    };

    var decode = function(c) {
      if (0x41 <= c && c <= 0x5a) {
        return c - 0x41;
      } else if (0x61 <= c && c <= 0x7a) {
        return c - 0x61 + 26;
      } else if (0x30 <= c && c <= 0x39) {
        return c - 0x30 + 52;
      } else if (c == 0x2b) {
        return 62;
      } else if (c == 0x2f) {
        return 63;
      } else {
        throw 'c:' + c;
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // gifImage (B/W)
  //---------------------------------------------------------------------

  var gifImage = function(width, height) {

    var _width = width;
    var _height = height;
    var _data = new Array(width * height);

    var _this = {};

    _this.setPixel = function(x, y, pixel) {
      _data[y * _width + x] = pixel;
    };

    _this.write = function(out) {

      //---------------------------------
      // GIF Signature

      out.writeString('GIF87a');

      //---------------------------------
      // Screen Descriptor

      out.writeShort(_width);
      out.writeShort(_height);

      out.writeByte(0x80); // 2bit
      out.writeByte(0);
      out.writeByte(0);

      //---------------------------------
      // Global Color Map

      // black
      out.writeByte(0x00);
      out.writeByte(0x00);
      out.writeByte(0x00);

      // white
      out.writeByte(0xff);
      out.writeByte(0xff);
      out.writeByte(0xff);

      //---------------------------------
      // Image Descriptor

      out.writeString(',');
      out.writeShort(0);
      out.writeShort(0);
      out.writeShort(_width);
      out.writeShort(_height);
      out.writeByte(0);

      //---------------------------------
      // Local Color Map

      //---------------------------------
      // Raster Data

      var lzwMinCodeSize = 2;
      var raster = getLZWRaster(lzwMinCodeSize);

      out.writeByte(lzwMinCodeSize);

      var offset = 0;

      while (raster.length - offset > 255) {
        out.writeByte(255);
        out.writeBytes(raster, offset, 255);
        offset += 255;
      }

      out.writeByte(raster.length - offset);
      out.writeBytes(raster, offset, raster.length - offset);
      out.writeByte(0x00);

      //---------------------------------
      // GIF Terminator
      out.writeString(';');
    };

    var bitOutputStream = function(out) {

      var _out = out;
      var _bitLength = 0;
      var _bitBuffer = 0;

      var _this = {};

      _this.write = function(data, length) {

        if ( (data >>> length) != 0) {
          throw 'length over';
        }

        while (_bitLength + length >= 8) {
          _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
          length -= (8 - _bitLength);
          data >>>= (8 - _bitLength);
          _bitBuffer = 0;
          _bitLength = 0;
        }

        _bitBuffer = (data << _bitLength) | _bitBuffer;
        _bitLength = _bitLength + length;
      };

      _this.flush = function() {
        if (_bitLength > 0) {
          _out.writeByte(_bitBuffer);
        }
      };

      return _this;
    };

    var getLZWRaster = function(lzwMinCodeSize) {

      var clearCode = 1 << lzwMinCodeSize;
      var endCode = (1 << lzwMinCodeSize) + 1;
      var bitLength = lzwMinCodeSize + 1;

      // Setup LZWTable
      var table = lzwTable();

      for (var i = 0; i < clearCode; i += 1) {
        table.add(String.fromCharCode(i) );
      }
      table.add(String.fromCharCode(clearCode) );
      table.add(String.fromCharCode(endCode) );

      var byteOut = byteArrayOutputStream();
      var bitOut = bitOutputStream(byteOut);

      // clear code
      bitOut.write(clearCode, bitLength);

      var dataIndex = 0;

      var s = String.fromCharCode(_data[dataIndex]);
      dataIndex += 1;

      while (dataIndex < _data.length) {

        var c = String.fromCharCode(_data[dataIndex]);
        dataIndex += 1;

        if (table.contains(s + c) ) {

          s = s + c;

        } else {

          bitOut.write(table.indexOf(s), bitLength);

          if (table.size() < 0xfff) {

            if (table.size() == (1 << bitLength) ) {
              bitLength += 1;
            }

            table.add(s + c);
          }

          s = c;
        }
      }

      bitOut.write(table.indexOf(s), bitLength);

      // end code
      bitOut.write(endCode, bitLength);

      bitOut.flush();

      return byteOut.toByteArray();
    };

    var lzwTable = function() {

      var _map = {};
      var _size = 0;

      var _this = {};

      _this.add = function(key) {
        if (_this.contains(key) ) {
          throw 'dup key:' + key;
        }
        _map[key] = _size;
        _size += 1;
      };

      _this.size = function() {
        return _size;
      };

      _this.indexOf = function(key) {
        return _map[key];
      };

      _this.contains = function(key) {
        return typeof _map[key] != 'undefined';
      };

      return _this;
    };

    return _this;
  };

  var createDataURL = function(width, height, getPixel) {
    var gif = gifImage(width, height);
    for (var y = 0; y < height; y += 1) {
      for (var x = 0; x < width; x += 1) {
        gif.setPixel(x, y, getPixel(x, y) );
      }
    }

    var b = byteArrayOutputStream();
    gif.write(b);

    var base64 = base64EncodeOutputStream();
    var bytes = b.toByteArray();
    for (var i = 0; i < bytes.length; i += 1) {
      base64.writeByte(bytes[i]);
    }
    base64.flush();

    return 'data:image/gif;base64,' + base64;
  };

  //---------------------------------------------------------------------
  // returns qrcode function.

  return qrcode;
}();

// multibyte support
!function() {

  qrcode.stringToBytesFuncs['UTF-8'] = function(s) {
    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
          utf8.push(0xc0 | (charcode >> 6),
              0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
          utf8.push(0xe0 | (charcode >> 12),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
          i++;
          // UTF-16 encodes 0x10000-0x10FFFF by
          // subtracting 0x10000 and splitting the
          // 20 bits of 0x0-0xFFFFF into two halves
          charcode = 0x10000 + (((charcode & 0x3ff)<<10)
            | (str.charCodeAt(i) & 0x3ff));
          utf8.push(0xf0 | (charcode >>18),
              0x80 | ((charcode>>12) & 0x3f),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
      }
      return utf8;
    }
    return toUTF8Array(s);
  };

}();

(function (factory) {
  if (typeof define === 'function' && define.amd) {
      define([], factory);
  } else if (typeof exports === 'object') {
      module.exports = factory();
  }
}(function () {
    return qrcode;
}));
  </script>
  <!-- <script type="text/javascript" src="lib/qrio.js"></script> -->
  <script>
/*
 * QrioJS v0.10, QR Code Generator Widgets/QR and Bar Code Scanner Widgets
 *   July 2023, MIT License, project @ github/gregsidal
 *
 * Uses qrcode.js from github/kazuhikoarase
 * Detector code adapted from github/kazuhikoarase
 *
 * To use widgets in a page, include qrio.css/qrcode.js/qrio.js, and place at bottom of HTML:
 *   <div id="qrio-generator-html"></div>
 *   <div id="qrio-reader-html"></div>
 *
 * During page init (onload or onDOMContentLoaded) call:
 *   QRIO.generator.insertHTML();
 *   QRIO.reader.insertHTML();
 *
 * See QRIO.generator.HTML/QRIO.reader.HTML for default HTML; see qrio.css for default css
 *
 * To generate a QR code:
 *   QRIO.generator.open( message[, opts] );  // message is HTMLElement or string containing message to encode
 *
 * To scan QR and/or bar codes:
 *   QRIO.reader.open( message[, callback] );  // message is HTMLElement to receive message(s), can be null
 *     callback( messages )  // messages is an array of strings containing selected message(s)
 *
 * To create specific widget instances:
 *
 * QRIO.Generator:
 *   init:    var qrg = new QRIO.Generator()
 *   open:    qrg.open( message[, opts] )     // message is an HTMLElement or a string 
 *   gen:     qrg.gen( message[, opts] )      // returns gif data url (no ui), message is string
 *
 * QRIO.Reader: 
 *   init:    var qrr = new QRIO.Reader()
 *   start:   qrr.open( message[, callback] ) // message is HTMLElement (can be null)
 *
 * ID name construction:
 *   appid + funid[module] + suffix
 *
 * To set name prefixes (when using non-default html/css):
 *   QRIO.setappid( appid );           //default 'qrio-'
 *   QRIO.setfunid( 'g'|'r', funid );  //defaults 'generator-' and 'reader-'
 *
 * If browser doesn't support the native BarcodeDetector API:
 *   QRIO.reader.detectorPolyfill will be used instead if defined
 *   (a 'BarcodeDetectorPolyfill' module is available from private com, license may be required)
 */

/*
General
*/
var QRIO = {

  _debug: false,
  appid: 'qrio-',
  funids: {g: 'generator-', r: 'reader-'},
  setappid: function( aid ) {if (aid) QRIO.appid = aid;},
  setfunid: function( fn, fid ) {if (fid) QRIO.funids[fn] = fid;},

  fullid: function( fn, id ) {return QRIO.appid + QRIO.funids[fn] + id;},
  e: function( fn, id ) {
    var fullid = QRIO.fullid( fn, id );
    return document.getElementById( fullid );
  },
  pute: function( e, res ) {
    if (e)
      if ((e instanceof HTMLInputElement) || (e instanceof HTMLTextAreaElement))
        e.value = res;
      else
        e.innerHTML = res;
  },
  put: function( fn, id, res ) {
    console.log( res );
    var e = QRIO.e( fn, id );
    QRIO.pute( e, res );
  },
  gete: function( e ) {
    if (e)
      if ((e instanceof HTMLInputElement) || (e instanceof HTMLTextAreaElement))
        return e.value;
      else
        return e.innerHTML;
  },
  get: function( fn, id ) {
    var e = QRIO.e( fn, id );
    return QRIO.gete( e );
  },
  classname: function( cn ) {return QRIO.appid + cn;},
  remclass: function( fn, id, cn ) {QRIO.e(fn,id).classList.remove( QRIO.classname(cn) );},
  addclass: function( fn, id, cn ) {QRIO.e(fn,id).classList.add( QRIO.classname(cn) );},
  open: function( fn, id ) {QRIO.remclass( fn, id, 'closed' );},
  close: function( fn, id ) {QRIO.addclass( fn, id, 'closed' );},
  showres: function( fn, res ) {QRIO.put( fn, 'status', res );},
  debug: function( fn, msg ) {
    if (QRIO._debug) {
      console.log( msg );
      QRIO.e( fn, 'status' ).innerHTML += "<br/><br/>" + msg;
    }
  }
};

/*
Encoders
*/
QRIO.generator = {
  open: function( message, opts ) {
    QRIO.generator.__qrg = QRIO.generator.__qrg ? QRIO.generator.__qrg : new QRIO.Generator();
    QRIO.generator.__qrg.open( message, opts );
  },
  html:
    '<div id="qrio-generator-home" class="qrio-widget qrio-closed">' +
      '<div class="qrio-controls">' +
        '<div id="qrio-generator-status" class="qrio-status">Initializing...</div>' +
        '<button id="qrio-generator-exitbtn" class="qrio-exitbtn">Done</button>' +
      '</div>' +
      '<div class="qrio-imgwrap">' +
        '<img class="qrio-img qrio-fitted" id="qrio-generator-img"/>' +
      '</div>' +
    '</div>',
  insertHTML: function() {QRIO.put( 'g', 'html', QRIO.generator.html );}
}

/* 
Encoder and viewer
*/
QRIO.Generator = function() {

  function showres( res ) {QRIO.showres( 'g', res );}
  function debug( msg ) {QRIO.debug( 'g', msg );}

  var img = QRIO.e( 'g', 'img' );
  var exitbtn = QRIO.e( 'g', 'exitbtn' );
  exitbtn.onclick = function() {close();}

  /* encode message and show it in view box */
  this.open = function( message, inopts ) {
    var idu;
    try {
      var text = message;
      if (message instanceof HTMLElement)
        text = QRIO.gete( message );
      if (!text)
        return alert( "Provide message to encode" );
      idu = this.gen( text, inopts );
      img.src = idu;
      var tmsg = text;
      if (inopts && inopts.maxtextviewlen)
        tmsg = text.length > inopts.maxtextviewlen ? 
          (text.slice(0,inopts.maxtextviewlen/3) + ".." + text.slice(text.length-(inopts.maxtextviewlen/3))) : text;
      showres( tmsg );
      QRIO.open( 'g', 'home' );
    }
    catch( e ) {
      var es = 'QRcode generation failed (response was: "' + e + '")';
      if (es.indexOf( "overflow" ) >= 0)
        es += ". The message may be too large to fit into a QR code.";
      alert( es );
    }
    return idu;
  }
  var close = function() {
    QRIO.close( 'g', 'home' );
  }
  this.close = function() {return close();}

  /* encode message and return data url of gif */
  this.gen = function( text, inopts ) {
    if (!text)
      throw( "No message to encode" );
    var opts = inopts ? inopts : {};
    opts = {
        typeNumber: opts.typeNumber ? opts.typeNumber : '0',
        errorCorrectionLevel: opts.errorCorrectionLevel ? opts.errorCorrectionLevel : 'M', 
        mode: opts.mode ? opts.mode : 'Byte', 
        mb: opts.mb ? opts.mb : 'UTF-8', 
        sizepx: opts.sizepx ? opts.sizepx : 0,
        margin: opts.margin ? opts.margin : 0,
        cellsize: opts.cellsize ? opts.cellsize : 8
    };
    /* encode */
    qrcode.stringToBytes = qrcode.stringToBytesFuncs[opts.mb];
    var qr = qrcode( opts.typeNumber || 4, opts.errorCorrectionLevel || 'M' );
    //text = text.replace(/^[\s\u3000]+|[\s\u3000]+$/g, '');
    qr.addData( text, opts.mode );
    qr.make();
    /* gen image*/
    /*
    if (opts.sizepx && opts.sizepx > window.innerWidth)  //must be entirely visible w/o scrolling
      opts.sizepx = window.innerWidth;
    if (opts.sizepx && opts.sizepx > window.innerHeight)  //must be entirely visible w/o scrolling
      opts.sizepx = window.innerHeight;
    */
    opts.cellsize = opts.sizepx ? Math.floor(opts.sizepx/qr.getModuleCount()) : opts.cellsize;
    opts.margin = opts.cellsize; 
    return qr.createDataURL( opts.cellsize, opts.margin );
  }
}

/*
Reader widgets
*/
QRIO.reader = {
  open: function( e, callback ) {  // global reader
    QRIO.reader.__qrr = QRIO.reader__qrr ? QRIO.reader.__qrr : new QRIO.Reader();
    QRIO.reader.__qrr.open( e, callback );
  },
  html:
    '<div id="qrio-reader-home" class="qrio-widget qrio-closed">' +
      '<div class="qrio-imgwrap qrio-scroll">' +
        '<img id="qrio-reader-selectedimg" class="qrio-img qrio-closed"/>' +
        '<svg id="qrio-reader-svgoverlay" class="qrio-overlay qrio-img qrio-closed"></svg>' +
      '</div>' +
      '<div class="qrio-controls">' +
        '<label for="qrio-reader-camerainput" id="qrio-reader-camerainputlabel">Camera</label>' +
        '<input id="qrio-reader-camerainput" type="file" accept="image/*" capture/>' +
        '<button id="qrio-reader-exitbtn" class="qrio-exitbtn">Done</button>' +
        '<div id="qrio-reader-status" class="qrio-status">Initializing...</div>' +
      '</div>' +
      '<input id="qrio-reader-fileinput" type="file" accept="image/*"/>' +
    '</div>',
  insertHTML: function() {QRIO.put( 'r', 'html', QRIO.reader.html );},
  alerts: {
    nodetector: 
        "Browser lacks support for QR and bar code scanning. " + 
        "Try Chrome on Android (most recent version), or use  " + 
        "a native app that can scan codes to clipboard.",
    nodetectorshort: 
        "No detection capability in browser",
    nofile:
        "Failed to open file or camera",
    ready: 
        "Use camera to snap photo to be scanned for QR and bar codes " +
        "(camera capture is generally only available on mobile devices).  " +
        "Photos can also be opened from files.",
    notanimg: 
        "Image not recognized"
  },
  setalerts: function( m ) {QRIO.reader.alerts = m;},
  detectorPolyfill: undefined,
  setpolyfill: function( p ) {QRIO.reader.detectorPolyfill = p;},
  multisel: false,
  setmultisel: function( m ) {QRIO.reader.multisel = m;},
  msgcache: {},
  msgcacheclr: function( m ) {QRIO.reader.msgcache = {};}, 
  msgcacheadd: function( m, id ) {QRIO.reader.msgcache[m] = id;},
  chkone: function( chkindex ) {
    if (!QRIO.reader.multisel)
      for( var i=0, e=true; e; i++ ) {
        e = QRIO.e( 'r', 'check'+i );
        if (e && i != chkindex && e.checked)
          e.checked = false;
      }
  },
  sel: function( selindex ) {
    e = QRIO.e( 'r', 'check'+selindex );
    if (e) {
      e.checked = !e.checked;
      QRIO.reader.chkone( selindex );
    }
  }
}

/*
Specific Reader widget
*/
QRIO.Reader = function() {

  function showres( res ) {QRIO.showres( 'r', res );}
  function debug( msg ) {QRIO.debug( 'r', msg );}
  function el( id ) {return QRIO.e( 'r', id );}

  this.setmultisel = function( m ) {
    if (QRIO.reader.multisel != m) {
      QRIO.reader.setmultisel( m );
      if (!m)
        QRIO.reader.chkone();
    }
  }

  this._settestpolyfill = function() {  //set a polyfill 4 crude testing on device w/o BarcodeDetector
    var _testbarcodes = [
      {cornerPoints: [{x:10, y:10},{x:150, y:10},{x:150, y:150},{x:10, y:150}],
       rawValue: "This is only a test, do not be alarmed"},
      {cornerPoints: [{x:160, y:10},{x:260, y:10},{x:270, y:150},{x:160, y:150}],
       rawValue: "https://github.com/gregsidal"}
      /*,{cornerPoints: [{x:160, y:10},{x:260, y:10},{x:270, y:150},{x:160, y:150}],
       rawValue: "This is just another test, still no cause for alarm "},
      {cornerPoints: [{x:10, y:200},{x:310, y:200},{x:290, y:290},{x:10, y:310}],
       rawValue: "0xfa8680013030d4194ec0b90e2c676db7115c4e40b66579c0a88025a049fca3030439eaa6e892154d0588" + 
                 "fef8aecb3ab239304fcd740a8f7228e23050a07ffb4a1845b9f95ea9c4285dab2e39d2385e4f48d06cf413"}*/
    ];
    var _case = 1;
    QRIO.reader.setpolyfill( 
      function() { 
        this.detect = async function( img ) { 
          _testbarcodes[0].rawValue += "__" + _case;
          //_testbarcodes[1].rawValue += "__" + _case;
          _case++;
          return _testbarcodes;
        }
      } 
    );
  }

  var exitbtn = el( 'exitbtn' );
  exitbtn.onclick = function() {close();}
  var barcode_detector;

  async function initdetector() {
    if (barcode_detector)
      return;
    var bcd;
    if ('BarcodeDetector' in window) {
      let formats = await window.BarcodeDetector.getSupportedFormats();
      if (formats.length > 0)
        bcd = window.BarcodeDetector;
    }
    else
      if (QRIO.reader.detectorPolyfill)
        bcd = QRIO.reader.detectorPolyfill;
      else
        return showres( QRIO.reader.alerts.nodetector );
    if (bcd) {
      barcode_detector = new bcd();
      showres( QRIO.reader.alerts.ready );
    }
  }

  var messagereceiver, callback;
  this.open = function( message, cb ) {
    try {
      cameraInput.value = fileInput.value = "";
      messagereceiver = message;
      callback = cb;
      initdetector();
      QRIO.open( 'r', 'home' );
    }
    catch( e ) {
      alert( 'Reader failed to run (response was: "' + e + '")' );
    }
  }
  var close = function() {
    var e = true, msgs = [];
    for( var i=0; e; i++ ) {
      e = el( 'check'+i );
      if (e && e.checked)
        msgs.push( QRIO.get('r','msg'+i) );
    }
    QRIO.close( 'r', 'home' );
    if (callback)
      if (callback( msgs ))
        return msgs;
    var msgstr = "";
    if (msgs.length)
      if (msgs.length == 1)
        msgstr = msgs[0];
      else
        msgstr = JSON.stringify( msgs, null, 2 );
    if (msgstr)
      QRIO.pute( messagereceiver, msgstr );
    return msgs;
  }
  this.close = function() {return close();}

  /* open image file and detect it */
  var cameraInput = el( 'camerainput' );
  var fileInput = el( 'fileinput' );
  cameraInput.onchange = fileInput.onchange = function( event ) {
    var file = event.target.files[0];
    if (!file)
      return;
    var reader = new FileReader();
    reader.onload = function( e ) {
      var img = el( 'selectedimg' );
      img.onerror = function() {
        cameraInput.value = fileInput.value = ""
        showdetect( false );
        showres( QRIO.reader.alerts['notanimg'] );
      }
      img.onload = async function() {
        clrOverlay();
        showdetect( true );
        if (!barcode_detector)
          return showres( QRIO.reader.alerts['nodetectorshort'] );
        var detectedCodes = await barcode_detector.detect( img );
        var json = JSON.stringify( detectedCodes, null, 2 );
        debug( json );
        setupOverlay( img );
        var o = {t:{x:img.naturalWidth,y:0}, flipaxes:true, s:{x:-1,y:1}};
        if (img.naturalWidth > img.naturalHeight)
          o = null;
        drawOverlay( detectedCodes, o );
        showMessages( detectedCodes );
      }
      img.src = e.target.result;
      //cameraInput.value = fileInput.value = this.value;
    }
    reader.onerror = function () {
      alert( QRIO.reader.alerts['nofile'] );
      showres( "" );
    }
    reader.readAsDataURL( file );
  }

  function showdetect( show ) {
    if (show)
      QRIO.open( 'r', 'selectedimg' ), QRIO.open( 'r', 'svgoverlay' );
    else
      QRIO.close( 'r', 'selectedimg' ), QRIO.close( 'r', 'svgoverlay' );
  }

  /* show messages with checkboxes */
  function showMessages( barcodes ) {
    for ( var m in QRIO.reader.msgcache )
      QRIO.reader.msgcache[m] = 99999;
    var msg = "<div class='" + QRIO.classname('msglist') + "'>";
    msg += barcodes.length ? "Messages extracted:" : "No codes recognized in image";
    for ( var i=0; i<barcodes.length; i++ )
      QRIO.reader.msgcacheadd( barcodes[i].rawValue, i % 5 );
    i = 0; var newmsgs = 0;
    for ( m in QRIO.reader.msgcache ) {
      if (QRIO.reader.msgcache[m] != 99999)
        newmsgs++;
      msg += drawMessageHTML( m, i, QRIO.reader.msgcache[m], (newmsgs == 1 && QRIO.reader.msgcache[m] != 99999) );
      i++;
    }
    msg += "</div>";
    showres( msg );
  }
  function drawMessageHTML( message, i, cn, chk ) {
    var c = " " + QRIO.classname('c') + cn;
    var msg = "<div class='" + QRIO.classname('extracted') + " " + QRIO.classname('msg') + c + "'/>";
    var id = "'" + QRIO.fullid( 'r', 'check'+i ) + "'";
    msg += '<input type="checkbox" ' +
           "id=" + id + (chk ? " checked " : "") + 
           'onclick="QRIO.reader.chkone(' + i + ')" '  +
           "class='" + QRIO.classname('check') + c + "'" + "/>";
    var chkid = id;
    var id = "'" + QRIO.fullid( 'r', 'msg'+i ) + "'";
    msg += "<span class='" + QRIO.classname('msg') + c + "' " +
           "id=" + id + 
           'onclick="QRIO.reader.sel(' + i + ')"'  +
           ">" + message + '</span>';
    if (message.slice(0,8) == "https://")
      msg += " <a href='" + message + "' class='" + QRIO.classname('target') + c + "' target=_blank></a>";
    return msg + "</div>";
  }

  /* machinery for svg overlay (to visually show detected codes)*/
  var svg = el( 'svgoverlay' );
  function setupOverlay( img ) {
    clrOverlay();
    if (!img.naturalWidth)
      return;
    var vb = "0 0 " + img.naturalWidth + " " + img.naturalHeight;
    debug( "svg viewBox: " + vb );
    svg.setAttribute( "viewBox", vb );
  }
  function clrOverlay() {
    svg.innerHTML = "";
  }
  function drawOverlay( barcodes, origin ) {
    svg.innerHTML = "";
    for ( var i=0; i<barcodes.length; i++ ) {
      var barcode = barcodes[i];
      var points = getPointsData( barcode.cornerPoints, origin );
      var polygon = document.createElementNS( "http://www.w3.org/2000/svg", "polygon" );
      polygon.setAttribute( "points", points );
      var c = " " + QRIO.classname('c') + (i % 5);
      polygon.setAttribute( "class", QRIO.classname('extracted') + c );
      svg.append( polygon );
      debug( "points: " + points );
      var text = document.createElementNS( "http://www.w3.org/2000/svg", "text" );
      text.innerHTML = barcode.rawValue;
      var txtpt = getMinPoint( barcode.cornerPoints, origin );
      text.setAttribute( "x", txtpt.x );
      text.setAttribute( "y", txtpt.y );
      text.setAttribute( "fill", "red" );
      text.setAttribute( "fontSize", "200" );
      //svg.append( text );
      debug( "text point: " + txtpt.x + "," + txtpt.y );
    }
  }
  function getPointsData( pts, origin ) {
    var pointsData = 
          getPointData(pts[0],origin) + " " +
          getPointData(pts[1],origin) + " " +
          getPointData(pts[2],origin) + " " +
          getPointData(pts[3],origin);
    return pointsData;
  }
  function getPointData( pt, origin ) {
    pt = getVwPoint( pt, origin );
    var ptData = pt.x + "," + pt.y;
    return ptData;
  }
  function getVwPoint( pto, origin ) {
    origin = origin ? origin : {t:{x:0,y:0}, flipaxes:false, s:{x:1,y:1}};
    var pt = pto;
    if (origin.flipaxes)
      pt = {x:pto.y, y:pto.x};
    return {x:origin.t.x + (pt.x*origin.s.x), y:origin.t.y + (pt.y*origin.s.y)};
  }
  function getMinPoint( pts, origin ) {
    var pt, minpt = {x:9999999,y:9999999};
    for( var i=0; i<pts.length; i++ ) {
      pt = getVwPoint( pts[i], origin );
      if (pt.x < minpt.x)
        minpt.x = pt.x;
      if (pt.y < minpt.y)
        minpt.y = pt.y;
    }
    return minpt;
  }

};
  </script>

  <script>
    var Demo = {
      onpageload: function() {
        QRIO.generator.insertHTML();
        QRIO.reader.insertHTML();
      },
      gen: function() {
        QRIO.generator.open( document.getElementById('msgin').value );
      },
      read: function() {
        Demo.qrr = Demo.qrr ? Demo.qrr : new QRIO.Reader();
        function callback( selectedmsgs ) {
        }
        Demo.qrr.setmultisel( document.getElementById('multisel').checked );
        //Demo.qrr._settestpolyfill();  // (crude test on devices w/o BarcodeDetector)
        Demo.qrr.open( document.getElementById('msgout'), callback );
      }
    }
  </script>

</head>

<body onload="Demo.onpageload();">

  <div class="index">
    <h3>QR-code Generator and Reader</h3>
    <div class="clickable" onclick="Demo.gen()">Generate</div>
    <textarea id="msgin">A message to encode.</textarea>
    <div class="clickable" onclick="Demo.read()">Scan</div>
    <input type="checkbox" id="multisel" class="chk"/><span class="chklabel">enable multiple selection</span>
    <textarea id="msgout">[Detected message(s) will be put here after scan]</textarea>
    <div class="tiny">QrioJS project
      <span class="clickable" onclick="QRIO.generator.open(this)">https://github.com/gregsidal</span>
    </div>
  </div>

  <div id="qrio-generator-html"></div>

  <div id="qrio-reader-html"></div>

</body>
</html>
